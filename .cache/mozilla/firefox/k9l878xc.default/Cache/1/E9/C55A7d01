/**
 * The base class for all views. It provides the following services:
 *
 * o Automatic registration with the model o Automatic response to notification &
 * actor callbacks from the model. o Several render utilities for creating
 * notifications and actors elements
 *
 * Extenders *must* override the buildView function to create their views. It is
 * called when all notifications have been loaded into the system.
 *
 */
if (!window.NautilusView) {


NautilusView = Class.create( {

  /**
   * Constructor.
   *
   * Valid view options include:
   *   :: hideCourses - whether to hide the course link that appears beside each notification
   *   :: hideCounts  - whether to hide the notification counts
   *
   * @param containerId  The id of the top-level container of this view
   * @param parentId     The id of the element that contains this view
   * @param viewOptions  various options that control the disposition of this view
   * @param renderAllNotificaitonsItems  Whether to show all items, even if their numbers exceeds the
   *                                     initial display threshold
   *
   */
  initialize: function(courseId, groupId, sourceIds, containerId, parentId, viewOptions, renderAllNotificationItems, noItemsMessage) {

    if (parentId) {

			this.courseId = courseId;
			this.groupId = groupId;
			this.sourceIds = sourceIds;
      this.viewId      = (NautilusView._viewCount++) + "-" + parentId;
      this.containerId = containerId;
      this.parentId    = parentId;
      this.viewOptions = viewOptions ? viewOptions : {};

      // initialize stuff
      this.expandedBlocks = [];
      this.expandedActors = $H();

      this.actorContainers = $H();
      this.actorRenderer = this.defaultActorRenderer;

      this.renderAllNotificationItems = renderAllNotificationItems;
      this.noItemsMessage = noItemsMessage;

      this.actionMenuId = null;

    }
    notification_controller.registerView( this );
  },


  /**
   * Display the view. Also register with the notification model.
   */
  display: function() {

    // if notifications have already finished loading, go ahead and build the
  // view
    if (notification_controller.getLoadStatus() == notification_controller.LOAD_COMPLETE ) {
      this.notificationsLoaded();
    }

  },

  /**
   * Creates the view. Extenders must override this function with thier own
   * implementations.
   */
  buildView: function() {
    alert("buildView not implemented");
  },

  /**
   * Deletes the contents of the view, and all of its blocks.
   */
  removeView: function() {
    $(this.parentId).down().remove();
    this.blocks = null;
  },

  /**
   * Specify a function that renders a notificaiton actor. The function should have the following
   * signature:
   *
   *   function(notification, actor menu)
   *
   * ... where "notification" is the notification to which the actor belong, "actor" is the
   * actor to be rendrered, and "menu" is the menu containing valid actions for that actor.
   * The function should return a node suitable for display within a list item (<li>).
   *
   * If no renderer is specified, the view will used the "defaultActorRenderer"
   * function.
   *
   * @see            defaultActorRenderer
   * @param renderer A function that renders a single notification actor
   * @return         An element containing the rendered actor
   */
  setActorRenderer: function(renderer) {
    this.actorRenderer = renderer;
  },

  /**
   * Returns an element that should follow the title in a notification element. If null,
   * renders nothing. This function should be overriden by child views.
   *
   * @param notification  The notification we're rendering
   * @param displayActors Whether this notification has associated actors
   */
  getNotificationTitleDecorator: function(notification, displayActors) {
    return null;
  },


  /**
   * The renderer we use to display notifications, by default. This can be overriden.
   *
   * @param notification   The notification to render
   * @param menu           The action menu for that notification
   * @param hasActors      Whether this notification has associated child actors
   * @return               An element containing the rendered notification
   */
  renderNotificationItem: function(notification, menu, hasActors) {

    var defaultAction = notification_controller.getDefaultAction(notification.viewId);

    // the elements that go into a notification entry
    var elements = [];

    if (defaultAction) {
      var actionHandler = "nautilus_utils.actionSelected('" + notification.viewId + "', '" + defaultAction.actionKey + "', true)";
      elements.push(Builder.node("a", {onclick: actionHandler, href: "javascript:void(0)" }, notification.title));
    }

    else {
      elements.push(notification.title);
    }

    elements.push(" ");

    // add any decorators that should follow the title
    var titleDecorator = this.getNotificationTitleDecorator(notification, hasActors);
    if (titleDecorator)
    {
      elements.push(titleDecorator);
    }

    elements.push(" ");
    // add the notification menu
    elements.push(menu);

    // display the name of the associated course (if this capability hasn't been
  // suppressed by our caller),
    // and a link to that course
    if (!this.viewOptions.hideCourses) {
      elements.push(" ");
      elements.push(this.renderNotificationItemCourse(notification));
    }

    return(Builder.node("span", elements));

  },


  /**
   * Render the notification item course line, which appears under the notification item.
   *
   * @param notification The notification in questions
   */
  renderNotificationItemCourse: function (notification) {

    // show the course name, and link to that course
    return Builder.node("div", {className: "course"},
             Builder.node("a", { target: "_top", href: notification_controller.getCourseLink(notification.courseId) },
                          notification.courseName));

  },



  /**
   * The renderer we use to display notification actors, by default. This can be overriden.
   *
   * @see                setActorRenderer
   * @param notification The notification to which the actor belongs
   * @param actor        The actor to render
   * @param menu         The action menu for that actor
   * @return             An element containing the rendered actor
   */
  defaultActorRenderer: function(notification, actor, menu) {
    return Builder.node("span", [actor.name, " ", menu]);
  },

  getExpandCollapseAlt : function ( isVisible, imgAlt )
  {
    // Change the title
    var expandStr = notification_controller.getResource("nautilus.view.expand","");
    var collapseStr = notification_controller.getResource("nautilus.view.collapse","");

    var title = "";
    if ( isVisible )
    {
      title = imgAlt.replace(expandStr,"");
      return notification_controller.getResource("nautilus.view.collapse",title);
    }
    else
    {
      title = imgAlt.replace(collapseStr,"");
      return notification_controller.getResource("nautilus.view.expand",title);
    }

  },
  /**
   * Show/hide the container that contains actors lists for a the given notification. If the
   * container has not yet been created, calls out to the model to grab the actors and
   * creates it.
   *
   * @param notificationId       The id whose notifications we seek
   * @param block
   * @param suppressRegistration If true, suppresses registration of the expansion
   *                             state with the underlying server
   */
  toggleActorContainer : function(notificationId, blockId, suppressRegistration) {

    var container = this.actorContainers.get(notificationId);

    var notificationEntryId = this._getNotificationElementId(notificationId);

    // if we've already created this action container, just toggle it
    if (container) {
      container.toggle();
    }

    // create the actor container then kick off an actor load request
    else {

      var actorListId =  this._getActorListElementId(notificationId);

      // create the actor container and register it with this view
      container = $(Builder.node("div", { id: this._getActorListElementId(notificationId)}));
      this.actorContainers.set(notificationId, container);

      // grab all the actors for this notification
      var actors = notification_controller.getActors(notificationId, this.blocks[blockId].actorKind);

      // if they've already been loaded, render and display them
      if (actors != notification_controller.LOAD_IN_PROGRESS) {
        var actorsList = this.createActorList(actors, notification_controller.getNotification(notificationId));
        container.appendChild(actorsList);
      }

      // place the actor container beneath its parent notification
      $(notificationEntryId).appendChild(container);

    }

    // toggle the expansion image
    var expansionImg = $(this._getExpansionImageId(notificationId));
    expansionImg.src = container.visible() ? "/images/ci/icons/minus.gif" : "/images/ci/icons/plus.gif";

    expansionImg.alt = this.getExpandCollapseAlt ( container.visible(), expansionImg.alt );
    expansionImg.parentNode.title = this.getExpandCollapseAlt ( container.visible(),  expansionImg.parentNode.title );

    // register the expansion state of the actor list
    if (!suppressRegistration) {
      this._registerExpansion
        (this._getActorExpansionStateId(notificationEntryId), container.visible());
    }

  },

  /**
   * Show/hide the discussion board container that contains actors lists for a the given notification.
   * If the container has not yet been created, calls out to the model to grab the actors and creates it.
   *
   * @param blockId        The id of the block
   * @param notificationId The id of the notification within the block
   * @param suppressRegistration If true, suppresses registration of the expansion
   *                             state with the underlying server
   */
  toggleGenericBlockActorContainer : function(blockId, notificationId, suppressRegistration) {

    var container = this.actorContainers.get(notificationId);

    var notificationEntryId = blockId + notificationId + "Li";
    var notificationDivId = blockId + notificationId + "Div";
    var notificationImgId = blockId + notificationId + "Img";

    // if we've already created this action container, just toggle it
    if (container) {
      container.toggle();
    }

    // load the actor container HTML block
    else {

      // create the actor container and register it with this view
      container = $(notificationDivId);
      container.toggle();
      this.actorContainers.set(notificationId, container);

    }

    // toggle the expansion image
    var notificationImg = $(notificationImgId);
    notificationImg.src = container.visible() ? "/images/ci/icons/minus.gif" : "/images/ci/icons/plus.gif";

    notificationImg.alt = this.getExpandCollapseAlt ( container.visible(), notificationImg.alt );
    notificationImg.parentNode.title =  this.getExpandCollapseAlt ( container.visible(), notificationImg.parentNode.title );

    // register the expansion state of the actor list
    if (!suppressRegistration) {
      this._registerExpansion(this._getActorExpansionStateId(notificationEntryId), container.visible());
    }

  },


  /**
   * Hides/shows the given category's block.
   *
   * @param blockId The id of the block to toggle
   * @param expand  A boolean indicating whether to expand (true) or collapse. If null,
   *                we'll simply toggle the block to the state opposite to its current
   *                disposition
   * @param suppressRegistration If true, suppresses registration of the expansion state
   *                             with the underlying server
   */
  toggleBlock: function(blockId, expand, suppressRegistration, blockIndex) {

    var blockListId = this._getBlockListId(blockId);
    var blockList   = $(blockListId);
    var blockHeader = $(this._getBlockHeaderElementId(blockId));
    var blockImg    = $(this._getBlockImgElementId(blockId));

    // if the user just wants a straight toggle, figure out which way to go
    if ( expand === null || expand === undefined )
    {
      expand = !blockList.visible();
    }

    if (expand) {
      blockHeader.addClassName("itemHeadOpen");
      blockList.show();
      blockImg.alt = notification_controller.getResource("nautilus.view.expand","");

    }
    else {
      blockHeader.removeClassName("itemHeadOpen");
      blockList.hide();
      blockImg.alt = notification_controller.getResource("nautilus.view.collapse","");
    }

    // register the expansion state of the block
    if (!suppressRegistration)
    {
      this._registerExpansion(blockListId, blockList.visible());
    }
    if (blockIndex !== null &&  blockIndex === 0 )
    {
      blockHeader.focus();
    }
  },


  /**
   * Expand/collapse all blocks in the view.
   *
   * @param expand If true, expands all. If false, collapses.
   */
  toggleAllBlocks: function(expand) {
    $H(this.blocks).values().each(
        function (block, index)
        {
          this.toggleBlock(block.id, expand, false, index) ;
        }.bind(this)
    );
  },


  // ----- callbacks

  notificationsLoaded: function() {

    // init
    this.expandedBlocks = [];
    this.expandedActors = $H();
    this.actorContainers = $H();

    // render the view
    this.buildView();

    // expand all blocks that were expanded last time the user was in this view
      this.expandedBlocks.each(function(blockId) {

        this.toggleBlock(blockId, true, true);

        // expand all actors lists within this pre-expanded block
        if (this.expandedActors.get(blockId)) {

          var block = this.blocks[blockId];

          if (block instanceof nautilus_utils.GenericBlock) {

            this.expandedActors.get(blockId).each(function(notificationId) {
              this.toggleGenericBlockActorContainer(blockId, notificationId, true);
            }.bind(this));

          }

          else {
            this.expandedActors.get(blockId).each(function(notificationId) {
              this.toggleActorContainer(notificationId, block.id, true);
            }.bind(this));
          }

        }
    }.bind(this));

    // let the parent module controller know that this view is finished
    module_controller.registerViewComplete(this.containerId, this.viewId);

  },

  /**
   * Called  when all notifications have been removed from the model underlying this view.
   */
  notificationsUnloaded: function() {
    this.removeView();
  },


  /**
   * Called when a pending actor request is complete.
   *
   * @param notificationId  The notification to which the actors belong
   * @param actors          The actors
   */
  actorsLoaded: function(notificationId, actors) {

    var container = this.actorContainers.get(notificationId);

    if (actors && container) {
      container.appendChild( this.createActorList(actors, notification_controller.getNotification(notificationId)) );
    }
  },


  /**
   * Called when a pending actor removal request is complete.
   *
   * @param actorId  The id of the actor that was removed.
   */
  actorRemoved: function(actorId) {
    var elementId = this._getActorElementId(actorId);
    if ( $(elementId) ) {
      $(elementId).remove();
      // new Effect.Highlight(elementId, { duration: 0.3, afterFinish:
    // function(obj) { $(elementId).remove() }});
    }

  },


  /**
   * Reacts to the removal of notifications. Deletes the notifications, updates counts,
   * and makes any necessary changes to the surrounding block structure.
   *
   * @param notificationViewId The notification that was removed
   */
  notificationRemoved: function(notificationViewId) {

    var elementId = this._getNotificationElementId(notificationViewId);
    var notification = $(elementId);

    if ( notification ) {

      var blockList = notification.up("ul");
      var blockElement = $(elementId).up("div");

      notification.remove();

      // figure out which block we're in
      var blockId = blockList.id.split(":::::").last();
      var block = this.blocks[blockId];

      // get the element that contains the block count
      var countElement = $(this._getBlockCountId(blockId));

      // if there are still notifications in this block, update the count
      if (blockList.down()) {

        // parse out the number
        /(\d+)/.exec(countElement.innerHTML);
        var count = parseInt(RegExp.$1, 10);

        // ... and update it
        countElement.innerHTML = " (" + (count - 1) + ")";

      }

      // no notifications left; if this block is marked to never disappear,
      // set the count to zero and display the empty msg
      else if (block.alwaysDisplay) {

        countElement.innerHTML = " (0)";

        var emptyBlockNode = $(this.renderNoNotificationsMsg(block.noNotificationsMsg));
        var blockContainer = blockElement.up();

        blockElement.remove();
        blockContainer.appendChild(emptyBlockNode);

      }

      // otherwise delete the block
      else {

        // get the main container for all the blocks
        var blocksContainer = blockElement.up("div");

        blockElement.up().remove();

        // if there aren't any more blocks left, put up the "no notifications"
    // msg
        if (!blocksContainer.down(2)) {

          // replace the blocks with a "no notifications" msg
          blocksContainer.down().remove();
          blocksContainer.appendChild(this.renderNoNotificationsMsg());

        }

      }

    }
  },


  // ----- renderering

  /**
   * Renders a view, consisting of one or more blocks. If the incoming list is
   * null, instead renders a standard "no notifications" message.
   *
   * @param blocks
   *            An array of NautilusBlock objects
   * @param sort
   *            Whether to sort the blocks alphabetically, by block name
   * @return All rendered blocks, in the form of an unordered list
   */
  renderNotificationView : function(blocks, sort) {

    // if there's nothing to display, say so
    if (!blocks || blocks.length === 0) {
      return this.renderNoNotificationsMsg();
    }

    // otherwise, build the list of blocks
    else {

      this.blocks = {};

      blocks.each(function(block) {
        this.blocks[block.id] = block;
      }.bind(this));

      // sort the incoming list by block name, if requested
      if (sort) {

        // convert the incoming list of blocks into a hash indexed by block name, so we
        // can sort
        var blockMap = $H();
        blocks.each(function(block) {blockMap.set(block.name, block);});
        blocks = blockMap.keys().sort().collect(function(name) { return blockMap.get(name); });
      }

      var list = Builder.node("ul", {className : "blockGroups"});

      // render the blocks
      blocks.each( function(block, index) {

        var blockItem = Builder.node("li", {id: this._getBlockElementId(block.id)});
        list.appendChild(blockItem);

        var header = this.renderBlockHeader(block, index === 0);

        var blockElement = null;

        if (block instanceof nautilus_utils.NotificationBlock) {
          blockElement = this.renderNotificationBlock(block, this.renderAllNotificationItems);
        }

        else if (block instanceof nautilus_utils.GenericBlock) {
          blockElement = this.renderGenericBlock(block);
        }

        var blockDiv = Builder.node("div", [header, blockElement]);

        blockItem.appendChild(blockDiv);

      }.bind(this));

      return list;

    }

  },


  renderBlockHeader : function(block, first) {

    var headerId = this._getBlockHeaderElementId(block.id);
    var headerContents = [block.name]; // blockName surround with "a" link tag
                    // to make it accessible
    var notificationCount;
    if (!this.viewOptions.hideCounts) {
      headerContents.push(" ");
      headerContents.push(notificationCount =
        Builder.node("span", {className: "newItemCount", id: this._getBlockCountId(block.id)}, "(" + block.numItems + ")"));
    }


    // add an invisible image with alt text describing the expand/collapse capabilities
    // of the block; this is for screen readers
    var expandMsg = notification_controller.getResource("nautilus.view.expandBlockTooltip");


    headerContents.push(Builder.node("img", {id:  this._getBlockImgElementId(block.id),
                                             src: "/images/spacer.gif",
                                             className: "hideoff",
                                             alt: expandMsg }));

    var header = Builder.node("span", { id: headerId,
                                        tabindex: "0",
                                        onclick: "nautilus_utils.toggleBlock('" + this.viewId + "', '" + block.id + "')",
                                        style: "cursor: pointer",
                                        className: "itemHead" //,
                                       // onfocus: "this.style.backgroundColor='#FF9';",
                                        //onblur: "this.style.backgroundColor='';"
                                        }, "" );

    Event.observe( header, 'keypress', this.headerToggle.bindAsEventListener( this, block ));

    // the first block doesn't have a top border -- we rely on the container to
    // provide that
    if (first)
    {
      $(header).setStyle ( {borderTop: "0"} );
    }

    var headerText = Builder.node(
      "span",
      {id: ("headerText" + headerId),
       className: "headerText"
      },
      headerContents);

    // Need to add the text before the context menu for Keyboard access
    header.appendChild(headerText);
    var confirmationMsg = notification_controller.getResource("nautilus.view.blockClearConfirmationMsg");

    // if this block contains notifications and the current user isn't an observer, include a block-level
    // "clear notifications" menu
    if ( block instanceof nautilus_utils.NotificationBlock && !notification_controller.isObserver ) {

      // create the anchor for the block clear menu
      var clearMenu = this._createContextMenu("contextMenu::" + headerId,block.name);

      // ... and listen for a click
      Event.observe(clearMenu, "click", function(event) {

        // note: Event.pointerX() is not working reliably in IE, so we have to use
        // browser-specific code in the code below
        this.displayMenu([{viewId: this.viewId}], clearMenu.id, function(item) {

          var menuItem = Builder.node("a",
            {href: "javascript:nautilus_utils.clearBlockNotifications('" + item.viewId + "', '" + block.id + "', '" + confirmationMsg.replace(/'/g, '\\\'') + "');nautilus_utils.onCloseLinkClick()",
             style: "cursor: pointer"},
             notification_controller.getResource("nautilus.view.clearAll"));

          var listElement = this.appendChild(Builder.node("li"));
          listElement.appendChild(menuItem);
        });

        // prevent the click event from propagating up to the titlebar
        Event.stop(event);

      }.bind(this));

      $(clearMenu).setStyle({cssFloat: 'right'});

      header.appendChild(clearMenu);
      header.appendChild(document.createTextNode(' ')) ;

    }
    return header;
  },

  headerToggle : function ( event, block )
  {
    var elem = Event.element( event );
    if ( event.element().up("span") === null )
    {
      if(event.keyCode== Event.KEY_RETURN ||event.keyCode==32)
      {
        nautilus_utils.toggleBlock(this.viewId , block.id );
      }
    }
  },

  renderGenericBlock : function(block) {

    // grab the contents of the block
    var genericBlockList = $(block.contentsId);

    // change the id of the the standard one for a block list
    genericBlockList.id = this._getBlockListId(block.id);
    block.contentsId = genericBlockList.id;

    return genericBlockList;

  },


  /**
   * Renders the contents of a single block.
   *
   * @param block                       The notification block to be rendered
   * @param renderAllNotificationItems  Flag indicating whether to display all notification items even if
   *                                    there are more than the initial-display thresshold
   * @return                            A list of notifications, rendered as an html list
   */
  renderNotificationBlock : function(block, renderAllNotificationItems) {

    var notificationsCount = $(block.numItems);
    var blockListId        = this._getBlockListId(block.id);


    var blockNode;

    // if there are no notifications in this block, render a "no notifications"
    // message
    if (notificationsCount === 0) {
      blockNode = $(this.renderNoNotificationsMsg(block.noNotificationsMsg));
      blockNode.setAttribute("id", blockListId);
      blockNode.setStyle( {display: "none"} );
    }

    // otherwise, render each notification
    else {

      var blockClass = "itemGroups" + (block.showActors ? " hierarchyList" : "");

      blockNode = Builder.node("ul", {id: blockListId, className : blockClass, style: 'display: none'});

      // if there are too many notifications to render, display a message
    // instead
      if (!renderAllNotificationItems && (notificationsCount > NautilusView.NOTIFICATION_OVERFLOW_THRESHOLD)) {
        blockNode.appendChild(this.buildExceedNotificationCountsItem(block));
      }

      // otherwise, display all notifications
      else {

        block.notifications.each( function(notification) {
          blockNode.appendChild(this.renderNotification(notification, block));
        }.bind(this));
      }

    }

    // if this block was open last time we were in here, open it up
    if (this._isExpanded(blockListId))
    {
      this.expandedBlocks.push(block.id);
    }

    return blockNode;

  },


  /**
   * Generate a message indicating no notifications were available.
   *
   * @param  msg The message to render. If null, default to the standard msg
   * @return A node containing the message.
   */
  renderNoNotificationsMsg: function(msg) {

    if (!msg)
    {
      msg = notification_controller.getResource("nautilus.view.noNotifications");
    }

    return Builder.node("p", {className: "noItems"}, msg);

  },

  /**
   * Renders the contents of a single block displaying there are more than 25 notification items.
   *
   * @param block The block containing more than 25 notifications
   * @return        An item containing message rendered as an html content
   */
  buildExceedNotificationCountsItem : function(block) {

    var itemId = this._getNotificationElementId(0);
    var item = Builder.node("li", {id: itemId, style: "text-align: center"});

    // add the overflow message
    var overflowMessage =
      notification_controller.getResource
        ("nautilus.view.notificationOverflow").replace("{num}", block.numItems);

    var elements = [overflowMessage];

    // what to do when the user asks to see everything
    var showAllAction =
      "nautilus_utils.renderNotificationBlockFromExceedItem('" + this.viewId + "', '" + block.id + "')";

    // what to do when the user asks to clear everything
    var clearConfirmationMsg = notification_controller.getResource("nautilus.view.blockClearConfirmationMsg");

    var clearAllAction =
      "nautilus_utils.clearBlockNotifications('" + this.viewId + "', '" + block.id + "', '" + clearConfirmationMsg.replace(/'/g, '\\\'') + "')";

    // the links for the above actions
    elements.push(Builder.node("div", {style: "padding-top: 10px"},
      [Builder.node("a", { href: "javascript:void(0)", onclick: showAllAction}, notification_controller.getResource("nautilus.view.showAll")),
       Builder.node("a", { href: "javascript:void(0)", onclick: clearAllAction, style: "padding-left: 14px;"}, notification_controller.getResource("nautilus.view.clearAll"))
      ]
    ));

    // append the elements to the item
    item.appendChild(Builder.node("span", elements));

    return item;
  },

  /**
   * Renders a single notification entry.
   *
   * @param notification The notification to render
   * @param block        The block to which it belongs
   */
  renderNotification: function(notification, block) {

    var itemId = this._getNotificationElementId(notification.viewId);
    var item = Builder.node("li", {id: itemId});

    // if the notifications in this block have child actors, and we're
  // displaying them, build
    // a list expansion widget thingy
    if (block.showActors) {

      var altStr = notification_controller.getResource("nautilus.view.expand", notification.title );
      var toggleIcon =
        Builder.node("a", {title:altStr, href:"javascript:void(0)", onclick: "nautilus_utils.toggleActors('" + this.viewId + "', '" + notification.viewId + "', '" + block.id + "')"},
          Builder.node("img", { id: this._getExpansionImageId(notification.viewId), src : "/images/ci/icons/plus.gif",alt:altStr  } ));

      item.appendChild(toggleIcon);

      // if this actor list was expanded the last time the user was in this
    // view,
      // arrange for it to be re-expanded after we finish building ourselves
      if ( this._isExpanded(this._getActorExpansionStateId(itemId)))
      {
        if (!this.expandedActors.get(block.id))
        {
          this.expandedActors.set(block.id,[]);
        }
        this.expandedActors.get(block.id).push(notification.viewId);
      }

    }

    // create the menu anchor, and listen for a click
    var menu = this._createContextMenu("nmenu::" + itemId + block.id, notification.title );

    Event.observe(menu, "click", function(event) {
      nautilus_utils.displayNotificationActionMenu
        (this.viewId, notification.viewId, block, menu.id);

        //Prevent click from bubbling up triggering default browser 'jump-to-anchor' behavior
        Event.stop(event);
    }.bind(this));

    // create this notification entry
    item.appendChild(this.renderNotificationItem(notification, menu, block.actorKind));

    return item;

  },

  /**
   * Renders the contents of a single notification block containing more than 25 notification items.
   *
   * @param viewId  Unique id of the Notification Container
   * @param blockId Unique Id of the block containing more than 25 notifications
   */
  renderNotificationBlockFromExceedItem : function(viewId, blockId) {
    // get the list of all blacks for the passed in container id
    var blocks = notification_controller.notificationContainers[viewId].blocks;

    // get the block form the list of blocks
    var myBlock = blocks[blockId];

    // get the notification block even if more than 25 items
    var blockElement = this.renderNotificationBlock(myBlock, true);

    // get the HTML Object for the specific div containing notification
    var blockDiv = $(this._getBlockElementId(myBlock.id)).down();

    // remove the child that displays the message containing more than 25 items
    blockDiv.removeChild($(this._getBlockListId(myBlock.id)));

    // append the child containing notifications
    blockDiv.appendChild(blockElement);

    // toggle the notifications block list to show
    blockElement.show();

  },


  /**
   * Create the actor container for the given notification
   *
   * @param actors          The actors to place in the container
   */
  createActorList : function (actors, notification) {

    var list = Builder.node ("ul", {className: "memberList", style: "display: block"} );

    actors.each( function(actor) {

      // create the menu anchor, and listen for a click
      var menu = this._createContextMenu("amenu::" + actor.id);

      Event.observe(menu, "click", function(event) {
        this.displayActorActionMenu(actor, menu.id);
        Event.stop(event);
      }.bind(this));

      // call out to the renderer to display the actor
      list.appendChild(
        Builder.node ("li",
          {id: this._getActorElementId(actor.id)},
          this.actorRenderer(notification_controller.getNotificationByInternalId(actor.eudItemId), actor, menu)));

    }.bind(this));

    return list;

  },

  /**
   * Returns a context menu
   *
   * @param id  The id to give the context menu
   * @return    The context menu
   */
  _createContextMenu : function (id, title) {
    var altStr = notification_controller.getResource("nautilus.view.optionMenuTooltip");
    if ( title )
    {
      altStr =  notification_controller.getResource("nautilus.view.option", title);
    }

    return Builder.node("a", { id: id, className: "cmimg editmode", href: "#menuDiv", title:altStr },
        Builder.node("img", { id: "cmimg_" + id,
                              src : "/images/ci/icons/cm_arrow.gif",
                              alt: altStr }));
  },


  /**
   * Create a menu for manipulating the view as a whole.
   *
   * @param buttonId The id of the button to which this menu should be attached
   */
  createViewMenu: function(buttonId) {

    var localButtonId = buttonId;
    // if the model isn't finished loading yet, we don't have enough info to
    // create the menu; register with the model, so that it'll inform us when
    // the load is complete
    if (notification_controller.getLoadStatus() != notification_controller.LOAD_COMPLETE) {

      notification_controller.registerLoadListener({
        loadComplete : function() {
          if (!this.actionMenuId)
          {
            this.createViewMenu(localButtonId);
          }
        }.bind(this)
      });

    }

    else {

      var viewPrefix = "notification_controller.notificationContainers['" + this.viewId + "'].";

      // add actions for category expansion and collapse
      var actors = [
        {title: notification_controller.getResource("nautilus.view.expandAll"),   href: "javascript: " + viewPrefix + "toggleAllBlocks(true)"},
        {title: notification_controller.getResource("nautilus.view.collapseAll"), href: "javascript: " + viewPrefix + "toggleAllBlocks(false)"}
      ];

      // if the current user is not an observer, add a clear all action as
    // well
      if (!notification_controller.isObserver) {

        actors.push
          ({title: notification_controller.getResource("nautilus.view.clearAll"),
            href: "javascript: nautilus_utils.clearAllNotifications('" +
                    this.viewId + "', '" + notification_controller.getResource("nautilus.view.viewClearConfirmationMsg").replace(/'/g, '\\\'') + "')"});
      }

      // add a "refresh" option that reloads notifications, clearing the cache
      actors.push ( {title: notification_controller.getResource("nautilus.view.refresh"), href: "javascript:notification_controller.refreshNotifications()"} );

      // create the action menu, and remember that we did so
      this.actionMenuId = this.createActionMenu(actors, buttonId);

    }

  },

  /**
   * Creates a menu with the given set of actions. If a buttonId is provided, associated the
   * menu with the given button. Otherwise, creates the associated menu button and returns
   * a div containing both menu & button.
   *
   * @param actions   The action to include in the menu
   * @param buttonId  The id of the button to associate the menu to
   * @return          The id of the created menu
   */
  createActionMenu: function(actions, buttonId) {

    var actionButtonId = buttonId ? buttonId : "actionButton_" + NautilusView._actionMenuCount;
    var actionMenuId   = "actionMenu_" + NautilusView._actionMenuCount++;

    var hideActionMenu = "$('" + actionMenuId + "').setStyle({display: 'none'})";
    var actionsLabel   = notification_controller.getResource("nautilus.view.actions");

    var button = buttonId ? $(buttonId) :
      Builder.node("a", { href: "#", id: actionButtonId, className: "actionMenuButton"},
                    [actionsLabel, " ", Builder.node("img", { src : "/images/ci/ng/more_options.gif" } ) ]);

    // Always set the href as an anchor to the Menus; Href are set in the JSP pages
    button.href = "#"+actionMenuId;

    var menuMouseOver = function() {nautilus_utils.displayActionMenu(actionButtonId, actionMenuId); };

    // the function to call when a mouseout event is fired around the menu;
    // we can't just hide the menu, because of the mouseout is fired whenever
    // the pointer enters an element *within* the menu div; in these cases, we
    // obviously don't want to close the menu; so we have to check every time
    // to make sure that the menu div isn't somewhere in our parent chain;
    // just really annoying. IE has a "mouseleave" event that doesn't bubble,
    // but there's no analog anywhere else. hence the nastiness below.
    var menuMouseOut  = function(e) {

      // figure out where the mouse is sitting after the mouse out event
      var destination = (e.relatedTarget) ? e.relatedTarget : e.toElement;

      // if it's not still inside the menu, hide the menu
      if (destination === null || destination.id != actionMenuId && !$(destination).up("div#" + actionMenuId)) {
        $(actionMenuId).setStyle({display: "none"});
      }

    };

    // create the contents of the menu
    var list = Builder.node("ul", {style: "border-top: 1px solid; border-color: #ACC2DF"});

    // create each menu item
    actions.each(function(action) {
      var link = Builder.node("a", { href: "javascript:void(0)", style: "cursor: pointer", onclick: action.href + ";" + hideActionMenu}, action.title);
      link.setAttribute( "role", "menuitem" );
      var ac = Builder.node("li", link);
      list.appendChild( ac );
      link.parentNode.setAttribute( "role", "presentation" );
    });

    // create the shell into which we'll slide the menu
    var menu = Builder.node("div",  {id: actionMenuId,  className: "cmdiv"}, list);

    // add open/close menu handlers
    Event.observe(button, "mouseover", menuMouseOver);
    Event.observe(button, "mouseout", menuMouseOut);
    Event.observe(menu, "mouseout", menuMouseOut);
    list.setAttribute( "role", "menu" );
    // Add Key Press action for the menu
    Event.observe( button, 'keydown', this.onActionButtonKeyPress.bindAsEventListener( this, actionButtonId, actionMenuId ));
    Event.observe( button, 'click', this.onLinkOpen.bindAsEventListener( this, actionButtonId, actionMenuId ));
    Event.observe( menu, 'keydown', this.onKeyPressFn.bindAsEventListener( this, actionButtonId, actionMenuId ));

    window.document.body.appendChild(menu);

    return actionMenuId;

  },

  /**
   * Display the action menu for the given notification
   *
   * @param notificationId The notification to display for
   * @param block          The block that this notification lives  in
   * @param parentButtonId The id of the button that invokes the menu
   */
  displayNotificationActionMenu : function(notificationId, block, parentButtonId) {

    var actions = notification_controller.getNotificationActions(notificationId);

    // display the action menu; automatically include a "remove" item if this
  // notifications
    // doesn't contain child actors
    this.displayMenu((block.showActors ? actions : [actions, {removeId: notificationId}].flatten()), parentButtonId, function(item) {

      var menuItem;

      // if this is not the standard "remove" menu item
      if (item.removeId === undefined) {
        menuItem = Builder.node("a",
          {onclick: "nautilus_utils.actionSelected('" + notificationId + "', '" +
                      item.actionKey + "', false, 'menuDiv')", href: "javascript:void(0)" }, item.actionName);
      }

      // otherwise render the remove item, but only if the current user is not an observer
      else if (!notification_controller.isObserver) {

        // if this notification represents multiple actors, then remove *all* of them
        if (block.actorKind) {

          menuItem = Builder.node("a", {
            onclick: "nautilus_utils.removeNotificationActorsForUser('" + item.removeId + "', 'menuDiv')",
            href: "javascript:void(0)"
          }, notification_controller.getResource("nautilus.view.remove"));

        }

        // otherwise, just remove the current notification
        else {

          menuItem = Builder.node("a", {
            onclick: "nautilus_utils.removeNotification('" + item.removeId + "', 'menuDiv')",
            href: "javascript:void(0)"
          }, notification_controller.getResource("nautilus.view.remove"));

        }

      }

      if (menuItem !== undefined) {
        // ... and add it to the list
        var listElement = this.appendChild(Builder.node("li"));
        listElement.appendChild(menuItem);
    }
    });

  },

  displayActorActionMenu: function(actor, parentMenuId) {

    var actions = notification_controller.getActorActions(actor.id);
    var viewId = this.viewId;

    this.displayMenu([actions, {actionKey: "EMAIL", actionName: notification_controller.getResource("nautilus.view.email")}, {removeId: actor.id}].flatten(), parentMenuId, function(item) {

      var menuItem;

      // create the remove menu item
      if (item.removeId && !notification_controller.isObserver) {
        menuItem = Builder.node("a",
          {onclick: "nautilus_utils.removeActor('" + viewId + "', '" + item.removeId + "', 'menuDiv')", href: "javascript:void(0)" },
           notification_controller.getResource("nautilus.view.remove"));
      }

      // create the menu item
      else {

        menuItem = Builder.node("a",
          {onclick: "nautilus_utils.actorActionSelected('" + actor.id + "', '" + item.actionKey + "', 'menuDiv')", href: "javascript:void(0)" },
          item.actionName);
      }

      if (menuItem !== undefined) {
        // ... and add it to the list
        var listElement = this.appendChild(Builder.node("li"));
        listElement.appendChild(menuItem);
      }

    });

  },

  /**
   * Remove the actor with the given id from this view.
   *
   * @param actorId  The actor with the given id
   */
  removeActor: function(actorId) {
    notification_controller.removeActor(actorId);
  },

  displayMenu: function(actions, parentButtonId, menuBuilder) {

    var menuDiv = $("menuDiv");

    if (!menuDiv) {

      // create the div that contains the menu
      menuDiv = Builder.node("div", {id: "menuDiv",
                                     className: "cmdiv",
                                     style: "display: 'none'; z-index: 200; position: 'absolute'"});

      // create the menu header (contains close link)
      var closeMsg = notification_controller.getResource("nautilus.view.menu.close");
      var menuHeader = Builder.node("ul",
                       Builder.node("li", {id: "contextmenubar_top", className: "contextmenubar_top"},
                       Builder.node("a", {href: "javascript:nautilus_utils.onCloseLinkClick()"},
                       Builder.node("img", {src: "/images/ci/ng/close_mini.gif", alt: closeMsg }))));

      menuDiv.appendChild(menuHeader);
      window.document.body.appendChild(menuDiv);

    }
    /* Add Keyboard listening */
    Event.observe( menuDiv, 'keydown', this.onKeyPressFn.bindAsEventListener( this, parentButtonId, "menuDiv" ));
    // Reinitialize the contextmenu by clearing out menu items from it's last use.
    // Note: The first item in the context menu is the top row which contains
    // the close button.
    // When we clear out the menuitems, clear out rows after the close button
    // row only.
    $(menuDiv).getElementsBySelector("ul > li").each( function (menuItem )   {
      if (menuItem.id != 'contextmenubar_top')
      {
        menuItem.remove();
      }
    });

    // create a list
    var list = menuDiv.down();

    // now run through each action, creating a menu item for it
    actions.each( menuBuilder.bind(list) );

    // add close content menu button javascript handler
    var contextMenuBarTopRow = $('contextmenubar_top');

    menuDiv.setStyle( { display: "block" });

    var parentButton = $(parentButtonId);
    var buttonPos = parentButton.cumulativeOffset();

    // the scroll position of the button, relative to its containing module
    var scrollOffset = parentButton.cumulativeScrollOffset();
    if (!scrollOffset)
    {
      scrollOffset = [0, 0];
    }

    // the scroll position of the parent module, relative to the document as a
    // whole
    var containerScrollOffset = $(this.containerId).up().cumulativeScrollOffset();
    if (!containerScrollOffset)
    {
      containerScrollOffset = [0, 0];
    }

    var buttonDimensions = parentButton.getDimensions();

    var bodyWidth = $(document.body).getWidth();
    var menuWidth = menuDiv.down().getWidth();

    var isRTL = page.util.isRTL();
    var overbounds = isRTL ?
      buttonPos[0] + parentButton.getWidth() - menuWidth < 0 : buttonPos[0] + menuWidth > bodyWidth;

    // if we're in right-to-left locale, or we're right up against the right
  // edge of
    // the browser, orient the menu leftwards
    if ( ( isRTL && !overbounds) || ( !isRTL && overbounds ) ) {
      buttonPos[0] = (buttonPos[0] - menuWidth + parentButton.getWidth() + (Prototype.Browser.IE ? 2 : 3));
    }

    // otherwise we're left-to-right, or butting up against the far left edge of the browser
    else {
      buttonPos[0] = (buttonPos[0] + (Prototype.Browser.IE ? 2 : 0));
    }

    // position the menu below the parent action button
    menuDiv.setStyle( { top:  ((buttonPos[1] - scrollOffset[1]) + containerScrollOffset[1] + (buttonDimensions.height * 2) + 1) + "px",
                        left: buttonPos[0] + "px" });
    //Setting the focus after positioning the menu
    list.down("a").focus();

  },


  /**
   * Register the expansion state of the item specified by the given id. The state
   * will be retained for the duration of the user's browser session.
   *
   * @param id        The id of the item whose expansion state we're tracking
   * @param expanded  True if the item is expanded
   */
  _registerExpansion: function(id, expanded) {
    notification_controller.registerNodeExpansion(id, expanded);
  },


  /**
   * Whether the item specified by the given id should be expanded.
   *
   * @param id The id of the item we're asking about
   * @return   Whether it's expanded
   */
  _isExpanded: function(id) {
    return notification_controller.isNodeExpanded(id);
  },


  /**
   * Returns the id to use for notification elements constructed for the
   * given notification.
   *
   * @param notificationId  The id of the notification
   * @return                The appropriate id
   */
  _getNotificationElementId : function (notificationId) {
    return this.viewId + "::" + notificationId;
  },

  /**
   * Returns the id to use for actor elements construted for the given
   * actor.
   *
   * @param actorId The actor whose element we're creating
   * @return         The id to use
   */
  _getActorElementId : function (actorId) {
    return this.viewId + "::" + actorId;
  },

  /**
   * Returns the id to use for actors list constructed for the
   * given notification.
   *
   * @param notificationId  The id of the notification
   * @return                The appropriate id of the actor list
   */
  _getActorListElementId : function(notificationId) {
    return this._getNotificationElementId(notificationId) + "_actors";
  },

  /**
   * Returns the id to use for the notification expansion image.
   *
   * @param notificationId  The id of the notification
   * @return                The appropriate id
   */
  _getExpansionImageId: function(notificationId) {
    return "toggle::" + this.viewId + "::" + notificationId;
  },

  /**
   * Returns the id to use for a block header element
   *
   * @param blockId  The id of the block
   * @return         The appropriate id
   */
  _getBlockHeaderElementId: function(blockId) {
    return "header::" + this.viewId + "::" + blockId;
  },

  /**
   * Returns the id to use for the block header's expand/collpase
   * state image tag.
   *
   * @param blockId  The id of the block
   * @return         The appropriate id
   */
  _getBlockImgElementId: function(blockId) {
    return "header::img::" + this.viewId + "::" + blockId;
  },

  /**
   * Returns the id to use for the block counts.
   *
   * @param blockId  The id of the block
   * @return         The appropriate id
   */
  _getBlockCountId: function(blockId) {
    return this._getBlockHeaderElementId(blockId) + "::count";
  },

  /**
   * Returns the id to use for a block element
   *
   * @param blockId  The id of the block
   * @return         The appropriate id
   */
  _getBlockElementId: function(blockId) {
    return "block::" + this.viewId + "::" + blockId;
  },

    /**
   * Returns the id to use for the list of notifications in a block
   *
   * @param blockId  The id of the block
   * @return         The appropriate id
   */
  _getBlockListId: function(blockId) {
    return "blocklist::" + this.viewId + ":::::" + blockId;
  },

  /**
   * The identifier to use to store the expansion state of the given actor.
   *
   * @param   itemId An id that uniquely identifies the head of the actor list
   * @return  The expanansion state id
   */
  _getActorExpansionStateId : function(itemId) {
    return "actor::" + this.viewId + "::" + itemId;
  },

  onLinkOpen: function( event,actionButtonId, actionMenuId )
  {
   this.toggleOpen(event, actionButtonId, actionMenuId);
   Event.stop( event );
  },

  toggleOpen: function( event, actionButtonId, actionMenuId)
  {
     var menu = $(actionMenuId);
     if ( !menu.visible() || menu.style.display == ""  )
     {
       nautilus_utils.displayActionMenu(actionButtonId, actionMenuId);
       // Take the Focus to the first item in the list
       menu.down("li > a").focus();
     }
     else
     {
       menu.setStyle({display: "none"});
     }
 },

 onActionButtonKeyPress: function( event, actionButtonId, actionMenuId )
 {
   var elem = Event.element ( event );
   var key = event.keyCode || event.which;
   if  ( elem.id != actionButtonId )
   {
     return;
   }
   if ( key == Event.KEY_RETURN  )
   {
     this.toggleOpen(event, actionButtonId, actionMenuId);
     Event.stop( event );
   }
 },

 onKeyPressFn: function( event, buttonId, menuId )
 {
   var elem = Event.element ( event );
   var key = event.keyCode || event.which;
   if ( key == Event.KEY_UP )
   {
     var previousElement = elem.parentNode.previousSibling;
     if ( previousElement !== null )
     {
       previousElement.down("a").focus();
     }
     else
     {
       /* Take the focus to the last element */
       var menu = $(menuId);
       var list = menu.down("ul").childNodes;
       Array.from(list).last().down("a").focus();
     }
     Event.stop( event );
   }
   else if ( key == Event.KEY_DOWN )
   {
     var nxtEle = elem.parentNode.nextSibling;
     if ( nxtEle !== null )
     {
       nxtEle.down("a").focus();
     }
     else
     {
       /* Take the focus to the first element */
       var m1 = $(menuId);
       m1.down("li > a").focus();
     }
     Event.stop( event );
   }
   else if ( key == Event.KEY_LEFT )
   {
     Event.stop( event );
   }
   else if ( key == Event.KEY_RIGHT )
   {
     Event.stop( event );
   }
   else if ( key == Event.KEY_ESC )
   {
     $(menuId).setStyle({display: "none"});
     $(buttonId).focus();
     Event.stop( event );
   }
   else if ( key == Event.KEY_TAB )
   {
     /*Check if this is the last */
     var nextElement = elem.parentNode.nextSibling;
     if ( nextElement === null )
     {
       /* Close the Menu */
       $(menuId).setStyle({display: "none"});
       /*
         * Setting the focus back to the button to it can move to the next link,
         * if not the tab will take the focus to the starting of the page.
         */
       $(buttonId).focus();
     }
   }
  },

  disableLinksForPreview: function( containerId, viewId, intervalId )
  {
    /* check if the load is complete and the view has content */
    if ( notification_controller.getLoadStatus() == notification_controller.LOAD_COMPLETE
        && $( viewId ).innerHTML.trim().length > 0 )
    {
      TabLayoutModules.disableLinks( $( containerId ) );
      window.clearInterval( intervalId );
      this.toggleAllBlocks( true );
    }
  }

});

/**
 * A static variable that keeps counts of the number of views created. Used to
 * assign each view a unique id.
 */
NautilusView._viewCount = 0;

NautilusView._actionMenuCount = 0;

/**
 * A static constant variable that keeps the maximum count of the notification
 * items in the block
 */
NautilusView.NOTIFICATION_OVERFLOW_THRESHOLD = 100;

/**
 * The source type that identifies a survey notification
 */
NautilusView.SURVEY_SOURCE_TYPE = "SU";


}
